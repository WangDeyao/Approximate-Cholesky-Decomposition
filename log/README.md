## Benchmarking
1. Make sure the flags in `CMakeLists.txt` are set correctly
2. Check if `test/test_solver` is calling the correct solver to be tested.
3. `bash run.sh`

## Profiling 

- `flops_log.txt`:
    - `r5301c7` counts the number of floating point operations (double precision).
    - for now the number is obtained from `perf stat -e r5301c7 /src/main.cpp`, which triggers `approxChol` multiple times
    - TODO: to generate the number from a single call to `approxChol`
        - for example, by using `perf stat -e r5301c7 /test/test_approxChol.cpp` and subtracting average overhead of creating a sparse matrix
- `general_metrics.txt`
    - most of these metrics are extracted in `plot.ipynb` and summerized in a table
    - tables are added to [https://docs.google.com/spreadsheets/d/1peTrHBhwSUDsgM9Qw27ardG6DiCBZcuJcOlolqa0AAA/edit#gid=869587198]
- `cache_log.txt`
    - metrics related to cache usage. Not all of them are summerized in the table (is it necessary?)
    - difference between `LLC`, `dTLB`, `iTLB`, `L1-dcache`:
        > - L1 is the Level-1 cache, the smallest and fastest one. LLC on the other hand refers to the last level of the cache hierarchy, thus denoting the largest but slowest cache.
        > - i vs. d distinguishes instruction cache from data cache. Only L1 is split in this way, other caches are shared between data and instructions.
        > - TLB refers to the translation lookaside buffer, a cache used when mapping virtual addresses to physical ones.Different TLB counters depending on whether the named address referred to an instruction or some data.
        > - For all data access, different counters are kept depending on whether the given memory location was read, written, or prefetched (i.e. retrieved for reading at some later time).
        > - The number of misses indicates how often a given item of data was accessed but not present in the cache.
    [https://stackoverflow.com/questions/12601474/what-are-perf-cache-events-meaning]

- `bin/perf_v${V}_e${E}.data`:
    - binary file that is generated by `perf report` on the 'main.cpp'.
    - On linux systems with `perf` installed, you can navigate this file interactively by 
    ``` sh
    $ perf report -i xxx.data
    ```
    This will probably provide more information than the log files.
- `report_main/pf_v${V}_e${E}0.txt`:
    - logs generated by `perf report --stdio --dsos=main`
    - shows the hottest functions used in `main.cpp`
- `annotate_main/p_v${V}_e${E}.txt`:
    - logs generated by `perf annotate --stdio --dsos=main`
- `annotate_approxChol/perf_annotate_v${V}_e${E}.txt`:
    - logs generated by `perf annotate --stdio --dsos=main --symbol=approxChol`
    - displays annotated C language source code for the function `approxChol`

    > The perf annotate command intersperses source and assembler language code. It uses the line numbers in the debug information to associate source lines with the assembler language. (The profile data is attributed to instructions during collection and the data must be “back annotated” to source.) As you can see, parts of the function body are displayed multiple times due to the code rearrangement made by the compiler. Compiler optimizations transform and move instructions, thereby complicating and obfuscating the association of instructions back to source. Sometimes, it makes it hard to read the disassembled instructions. (The TUI interface colors source and instructions differently — one more point in favor of TUI!) Source display is disabled with the --no-source option which makes it easier to read the annotated disassembly by itself.

## Reference
http://sandsoftwaresound.net/perf/

http://www.brendangregg.com/perf.html
